1. 你理解的多线程？
	- 多条线程同时工作，充分利用设备的多核，提高运行效率

2. iOS的多线程方案有哪几种？你更倾向于哪一种
    1. pthread
    2. NSThread
    3. GCD（倾向）
    4. NSOperation（倾向）

3. 你在项目中用过GCD吗？
	- 有，用于开启多线程处理复杂任务、线程同步、读写安全、延时任务、一次性任务、快速迭代等

4. GCD的队列类型
	- 串行队列
	- 并行队列
	- 主队列
	- 全局并发队列

5. 说一下NSOperationQueue和GCD的区别，以及各自的优势
	- NSOperationQueue
		1. 是OC对象，使用起来更加面向对象，底层是用GCD实现，其实就是对GCD的封装
		2. 加入队列的任务可以随时取消执行（已经开始的任务无法停止）
		3. 即使是在并发队列当中，同个队列里的不同任务之间可以设置依赖关系
		4. 可以简单设置任务的优先级，使得在并发队列中的任务也能区分先后地执行
		5. 可以监听任务的执行状态
		6. 可继承，定制自由度高
	- GCD
		1. 底层的C语言构成的API，轻量级的数据结构，性能比NSOperationQueue高
		2. 加入队列的任务无法停止执行
		3. 同个队列的不同的任务之间不可以设置依赖关系
		4. 只能区分队列的优先级，区分任务的优先级需要复杂代码
		5. 只能手动写代码监听执行状态
		6. 无法定制别的功能

6. 线程安全的处理手段有哪些？
	- 使用线程同步技术，就是协同步调，按预定的先后次序进行 —— 加锁

7. OC你了解的锁有哪些？
    1. ``OSSpinLock``：自旋锁
    2. ``os_unfair_lock``：取代``OSSpinLock``，不是自旋锁，应该属于互斥锁
    3. ``pthread_mutex``：互斥锁
    4. ``dipatch_semaphore``：信号量
    5. ``dispath_queue(DISPATCH_QUEUE_SERIAL)``：串行队列
    6. ``NSLock``：对``pthread_mutex普通锁``的封装
    7. ``NSRecursiveLock``：对``pthread_mutex递归锁``的封装
    8. ``NSCondition``：对``pthread_mutex普通锁``和``pthread_cond``的封装
    9. ``NSConditionLock``：对``NSCondition``的进一步封装，可以自定义条件值
    10. ``@synchronized``：对``os_unfair_recursive_lock``的封装

8. 自旋锁和互斥锁的对比（以及适用情况）
	- 自旋锁：等待锁的线程不会休眠，会一直等待，一直占用CPU资源
		- 预计线程等待锁的时间很短
		- 加锁的代码（临界区）经常被调用，但竞争情况很少发生（多条线程同时进入的情况）
		- CPU资源不紧张
		- 多核处理器
	- 互斥锁：等待锁的线程会处于休眠状态，锁可以用了就会唤醒线程
		- 预计线程等待锁的时间较长
		- 单核处理器
		- 临界区有IO操作（文件操作）
		- 临界区代码复杂或者循环量大
		- 临界区竞争非常激烈（多条线程同时进入的情况）

9. 使用以上锁需要注意哪些
	- 注意以上的使用场景，自旋锁要注意优先级反转问题，互斥锁要注意线程的生命周期

10. 用C/OC/C++，任选其一，实现自旋或互斥
	- 自旋锁用OSSpinLock，互斥锁用pthread_mutex

